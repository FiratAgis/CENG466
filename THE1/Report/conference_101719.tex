\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{CENG466, Fall 2022, THE 1\\

}

\author{\IEEEauthorblockN{1\textsuperscript{st} Fırat Ağış}
\IEEEauthorblockA{\textit{Department of Computer Engineering} \\
\textit{Middle East Technical University}\\
Ankara, Turkey \\
e2236867@ceng.metu.edu.tr}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
\IEEEauthorblockA{\textit{Department of Computer Engineering} \\
\textit{Middle East Technical University}\\
Ankara, Turkey \\
e1234567@ceng.metu.edu.tr}
}

\maketitle

\begin{abstract}
We implemented affine transformation using both bilinear and bicubic interpolation as well as histogram extraction, equalization, and adaptive equalization for the first Take Home Exam of Fall 2022 semester.
\end{abstract}

\begin{IEEEkeywords}
image processing, affine transformation, histogram equalization
\end{IEEEkeywords}

\section{Introduction}

\section{Affine Transformation}

\subsection{Rotation}
Because both bilinear and bicubic interpolation require finding the closest pixels in the input image for each pixel in the output image, we created an empty output image and rotated every pixel on it counterclockwise direction, finding the position it would have fall into in the input image. To achieve this for an image with $M\times N$ dimensions rotated $\alpha$ degrees, we used the following formula.
\begin{align}
	x_t(x) &= x - \dfrac{M}{2}\\
	y_t(y) &= y - \dfrac{N}{2}\\
	\textit{rot}_x(x,y) &= (x_t(x)\cos \alpha - y_t(y) \sin \alpha ) + \dfrac{M}{2}\\
	\textit{rot}_y(x,y) &= (x_t(x)\sin \alpha + y_t(y) \cos \alpha ) + \dfrac{N}{2}
\end{align}

\subsection{Bilinear Interpolation}


\subsection{Bicubic Interpolation}
Bicubic interpolation is defined as 
\begin{align}
	p(x, y) = \sum_{i = 0}^3\sum_{j = 0}^3a_{ij}x^iy^j,\label{BicubicDef}
\end{align}
calculated by finding the values of 16 coefficients in $[a_{ij}]$, whose values are informed by the 16 closest pixel. By only using the 4 closest pixel $(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$ and derivatives of them in horizontal, vertical, and diagonal directions, we can calculate the values of $[a_{ij}]$ as 
\begin{align}
	A &=
	\begin{bmatrix}
		a_{00} & a_{01} & a_{02} & a_{03}\\
		a_{10} & a_{11} & a_{12} & a_{13}\\
		a_{20} & a_{21} & a_{22} & a_{23}\\
		a_{30} & a_{31} & a_{32} & a_{33}
	\end{bmatrix}\\
	B &=
	\begin{bmatrix}
		1 & 0 & 0 & 0\\
		0 & 0 & 1 & 0\\
		-3 & 3 & -2 & -1\\
		2 & -2 & 1 & 1
	\end{bmatrix}\\
	F &=
	\begin{bmatrix}
		f(0,0) & f(0,1) & f_y(0,0) & f_y(0,1)\\
		f(1,0) & f(1,1) & f_y(1,0) & f_y(1,1)\\
		f_x(0,0) & f_x(0,1) & f_{xy}(0,0) & f_{xy}(0,1)\\
		f_x(1,0) & f_x(1,1) & f_{xy}(1,0) & f_{xy}(1,1)
	\end{bmatrix}\\
	A &= BFB^{-1}.\label{BicubicVal}
\end{align}

As most of the available libraries in our disposal does not calculate the values of $A$ for each given image, instead assigning them predetermined values (such as opencv), we decided to implement it by ourselves. To achieve this, we used a 3 step process.
\begin{itemize}
	\item \textit{Precomputation} We started by calculated the values of $f_x(x,y)$, $f_y(x,y)$, and $f_{xy}(x,y)$ for every pixel of the original input image where
	\begin{align}
		f_x(x,y) &= \dfrac{f(x+1,y)-f(x-1,y)}{2}\\
		f_y(x,y) &= \dfrac{f(x,y+1)-f(x,y-1)}{2}\\
		f_{xy}(x,y) &= \dfrac{f_x(x,y)+f_y(x,y)}{2}
	\end{align}
	using $0$ padding.
	\item \textit{Interpolation} We calculated the brightness value of every pixel of the output image using Equations \ref{BicubicDef} and \ref{BicubicVal}.
	\item \textit{Normalization} We normalized the brightness values of the output image to $[0,255]$, then rounded them to nearest integer value.
\end{itemize}

Because this order of operations requiring multiple matrix multiplications for each pixel in the output image, even with optimizations we implemented, this method took upto 10 minutes for the larger "a2.png" image.

\section{Histogram Equalization}


\subsection{Histogram Extraction}


\subsection{Histogram Equalization}



\subsection{Adaptive Histogram Equalization}


\section{Dependencies}
We used following libraries for the described reasons.
\begin{itemize}
	\item \textit{os:} Handling non-existant input or output paths.
	\item \textit{PIL:} Reading images and converting them arrays.
	\item \textit{numpy:} Executing array and matrix operations.
	\item \textit{math:} Performing trigonometric operations.
	\item \textit{mathplotlib:} Creating histograms as graphics and writing arrays as image files.
\end{itemize}

\begin{thebibliography}{00}
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
\bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
\bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
\bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
\bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
\bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
\bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
\end{thebibliography}

\end{document}
